<!doctype html>
<html lang="en">
 <head> 
  <meta charset="utf-8"> 
  <!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]--> 
  <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
  <meta name="generator" content="Asciidoctor 1.5.3"> 
  <title>Improving the performance of Gradle builds</title> 
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css"> 
  <link rel="stylesheet" href="./coderay-asciidoctor.css"> 
  <link rel="stylesheet" href="https://guides.gradle.org/asciidoctor.css"> 
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,400,700|Source+Code+Pro:500"> 
  <link rel="apple-touch-icon" sizes="180x180" href="https://guides.gradle.org/icon/apple-touch-icon.png"> 
  <link rel="icon" type="image/png" href="https://guides.gradle.org/icon/favicon-32x32.png" sizes="32x32"> 
  <link rel="icon" type="image/png" href="https://guides.gradle.org/icon/favicon-16x16.png" sizes="16x16"> 
  <link rel="manifest" href="https://guides.gradle.org/icon/manifest.json"> 
  <link rel="mask-icon" href="https://guides.gradle.org/icon/safari-pinned-tab.svg" color="#5bbad5"> 
  <link rel="shortcut icon" href="https://guides.gradle.org/icon/favicon.ico"> 
  <meta name="apple-mobile-web-app-title" content="Performance"> 
  <meta name="application-name" content="Performance"> 
  <meta name="msapplication-config" content="https://guides.gradle.org/icon/browserconfig.xml"> 
  <meta name="theme-color" content="#ffffff"> 
  <script>
  (function(i,s,o,g,r,a,m){i["GoogleAnalyticsObject"]=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,"script","https://www.google-analytics.com/analytics.js","ga");
  ga("create", "UA-4207603-1", "auto");
  ga("send", "pageview");
</script> 
 </head> 
 <body class="article toc2 toc-right"> 
  <div id="header">
   <div style="padding-top: 10px;">
    <a href="https://guides.gradle.org"><img src="http://guides.gradle.org/gradle-guides.svg" alt=""></a>
   </div> 
   <h1>Improving the performance of Gradle builds</h1> 
   <div id="toc" class="toc2"> 
    <div id="toctitle">
     Table of Contents
    </div> 
    <ul class="sectlevel1"> 
     <li><a href="#easy_improvements">1. Easy improvements</a> 
      <ul class="sectlevel2"> 
       <li><a href="#enable_the_daemon">1.1. Enable the daemon</a></li> 
       <li><a href="#use_latest_gradle_and_jvm_versions">1.2. Use latest Gradle and JVM versions</a></li> 
       <li><a href="#configure_on_demand">1.3. Configure on demand</a></li> 
       <li><a href="#parallel_builds">1.4. Parallel builds</a></li> 
      </ul> </li> 
     <li><a href="#profile_profile_profile">2. Profile, profile, profile</a> 
      <ul class="sectlevel2"> 
       <li><a href="#using_gradle_build_scans">2.1. Using Gradle build scans</a></li> 
       <li><a href="#profile_report">2.2. Profile report</a></li> 
       <li><a href="#understanding_the_profile_report_categories">2.3. Understanding the profile report categories</a></li> 
      </ul> </li> 
     <li><a href="#configuration">3. Configuration</a> 
      <ul class="sectlevel2"> 
       <li><a href="#apply_plugins_judiciously">3.1. Apply plugins judiciously</a></li> 
       <li><a href="#avoid_expensive_or_blocking_work">3.2. Avoid expensive or blocking work</a></li> 
       <li><a href="#statically_compile_tasks_and_plugins">3.3. Statically compile tasks and plugins</a></li> 
      </ul> </li> 
     <li><a href="#dependency_resolution">4. Dependency resolution</a> 
      <ul class="sectlevel2"> 
       <li><a href="#dynamic_and_snapshot_versions">4.1. Dynamic and snapshot versions</a></li> 
       <li><a href="#favor_dependency_resolution_during_execution">4.2. Favor dependency resolution during execution</a></li> 
       <li><a href="#avoid_unnecessary_and_unused_dependencies">4.3. Avoid unnecessary and unused dependencies</a></li> 
       <li><a href="#minimize_repository_count">4.4. Minimize repository count</a></li> 
       <li><a href="#be_careful_with_custom_dependency_resolution_logic">4.5. Be careful with custom dependency resolution logic</a></li> 
      </ul> </li> 
     <li><a href="#task_execution">5. Task execution</a> 
      <ul class="sectlevel2"> 
       <li><a href="#different_people_different_builds">5.1. Different people, different builds</a></li> 
       <li><a href="#incremental_build">5.2. Incremental build</a></li> 
       <li><a href="#partial_builds">5.3. Partial builds</a></li> 
      </ul> </li> 
     <li><a href="#other_performance_tweaks">6. Other performance tweaks</a> 
      <ul class="sectlevel2"> 
       <li><a href="#boost_daemon_s_heap_size">6.1. Boost daemon’s heap size</a></li> 
       <li><a href="#running_tests_jvm">6.2. Running tests (JVM)</a></li> 
       <li><a href="#compiling_java">6.3. Compiling Java</a></li> 
       <li><a href="#compiler_daemon">6.4. Compiler daemon</a></li> 
       <li><a href="#incremental_compilation">6.5. Incremental compilation</a></li> 
      </ul> </li> 
     <li><a href="#suggestions_for_android_builds">7. Suggestions for Android builds</a> 
      <ul class="sectlevel2"> 
       <li><a href="#use_the_latest_android_plugin">7.1. Use the latest Android plugin</a></li> 
       <li><a href="#invest_in_fast_cpus">7.2. Invest in fast CPUs</a></li> 
       <li><a href="#optimize_multidex_development_builds">7.3. Optimize multidex development builds</a></li> 
       <li><a href="#use_discretion_when_adding_build_types_and_flavors">7.4. Use discretion when adding build types and flavors</a></li> 
      </ul> </li> 
     <li><a href="#summary">8. Summary</a></li> 
    </ul> 
   </div> 
  </div> 
  <div id="content"> 
   <div id="preamble"> 
    <div class="sectionbody"> 
     <div class="paragraph"> 
      <p>Waiting is a part of life. Whether you’re waiting in line at a cinema or for the release of the latest must-have gadget, it’s something you learn to deal with. The same is often the case for builds and the waiting usually blocks you from doing something more productive. And the longer the build takes to complete, the more chance you’ll be distracted by something else in the meantime. On top of that, since you may be repeatedly running the build many times a day, even small periods of waiting can add up to significant disruption.</p> 
     </div> 
     <div class="paragraph"> 
      <p>All this means that it’s worth investing some time and effort into ensuring that your build runs as fast as possible. This guide offers several avenues you can explore to make a build run faster, along with plenty of detail on what sorts of things can adversely affect the performance of a build and why. Let’s start with some quick wins.</p> 
     </div> 
    </div> 
   </div> 
   <div class="sect1"> 
    <h2 id="easy_improvements"><a class="anchor" href="#easy_improvements"></a>1. Easy improvements</h2> 
    <div class="sectionbody"> 
     <div class="paragraph"> 
      <p>A guide on performance tuning would normally start with profiling and something about premature optimisation being the root of all evil, etc., etc. Profiling is definitely important and we discuss it later in the guide, but there are some things you can do that will impact all your builds for the better at the flick of a switch - metaphorically speaking.</p> 
     </div> 
     <div class="sect2"> 
      <h3 id="enable_the_daemon"><a class="anchor" href="#enable_the_daemon"></a>1.1. Enable the daemon</h3> 
      <div class="paragraph"> 
       <p>The Gradle daemon is a mechanism for improving the performance of Gradle. As of Gradle 3.0, the daemon is enabled by default but if you are using an older version, you should definitely enable it. You will see big improvements in build speed by doing so. You can learn how to do that <a href="https://docs.gradle.org/2.14/userguide/gradle_daemon.html">in the 2.14 user guide</a>.</p> 
      </div> 
      <div class="admonitionblock caution"> 
       <table> 
        <tbody>
         <tr> 
          <td class="icon"> <i class="fa icon-caution" title="Caution"></i> </td> 
          <td class="content"> 
           <div class="paragraph"> 
            <p>You should take particular care when using the daemon with a build that calls into third-party Java <code>main()</code> methods, such as those provided with JVM-based compilers. It’s tempting to run Java code from within the Gradle VM in order to avoid the cost of spawning a new process, but if that code holds onto memory after it finishes, then it causes problems for the daemon.</p> 
           </div> 
           <div class="paragraph"> 
            <p>For the sake of daemon stability, you should use the <code>JavaExec</code> task to execute the code in a separate process.</p> 
           </div> </td> 
         </tr> 
        </tbody>
       </table> 
      </div> 
      <div class="paragraph"> 
       <p>The recommendation for pre-3.0 versions of Gradle is to enable the daemon for developer machines and disable it for continuous integration servers. This is because the daemon is a background process that may require manual intervention from time to time and that’s not always easy when the process is on a separate machine from where you’re sitting. You also need to factor in whether you run many builds with different VM configurations, which will lead to each build having its own daemon and a potential sea of daemon processes at any one time.</p> 
      </div> 
      <div class="paragraph"> 
       <p>Nonetheless, if build times on your CI server hurt developer productivity, you should definitely consider enabling the daemon there. Alternatively, upgrade to the latest version of Gradle to benefit from improvements in the robustness of the daemon.</p> 
      </div> 
     </div> 
     <div class="sect2"> 
      <h3 id="use_latest_gradle_and_jvm_versions"><a class="anchor" href="#use_latest_gradle_and_jvm_versions"></a>1.2. Use latest Gradle and JVM versions</h3> 
      <div class="paragraph"> 
       <p>The Gradle team works regularly on improving the performance of different aspects of Gradle builds. If you’re using an old version of Gradle, you’re missing out on the benefits of that work. Try upgrading to the latest version of Gradle to see what kind of impact it has. Doing so is low risk because very few things break between minor versions of Gradle.</p> 
      </div> 
      <div class="paragraph"> 
       <p>Going up a major version is often just as easy and definitely recommended when available. Just be aware that this is when deprecations become failures. So be sure to fix those deprecation warnings!</p> 
      </div> 
      <div class="paragraph"> 
       <p>As Gradle runs on the JVM, improvements in the performance of the latter will often benefit Gradle. Hence, you should consider running Gradle with the latest major version of the JVM.</p> 
      </div> 
     </div> 
     <div class="sect2"> 
      <h3 id="configure_on_demand"><a class="anchor" href="#configure_on_demand"></a>1.3. Configure on demand</h3> 
      <div class="paragraph"> 
       <p>Imagine you have 300 subprojects all managed by a single Gradle build. Even if the configuration time for each project is just half a second, that means every build will take at last 300 x 0.5s = 2.5 minutes! That’s why it’s particularly crucial to keep a close eye on configuration times for projects that have a lot of modules.</p> 
      </div> 
      <div class="paragraph"> 
       <p>With that in mind, wouldn’t it be better if Gradle only configured the projects that were actually required to execute the requested task(s)? Of course, and that’s where the <code>--configure-on-demand</code> command line option comes in. It avoids a lot of unnecessary configuration at the cost of working out which projects are required. We wouldn’t recommend using it if you only have a small number of quick-to-configure subprojects, but otherwise you should try it.</p> 
      </div> 
      <div class="admonitionblock note"> 
       <table> 
        <tbody>
         <tr> 
          <td class="icon"> <i class="fa icon-note" title="Note"></i> </td> 
          <td class="content"> Configure on demand will only work reliably when you have decoupled projects or explicit (rather than implicit) inter-project dependencies. You can learn more about <a href="https://docs.gradle.org/current/userguide/multi_project_builds.html#sec:decoupled_projects">decoupled projects</a> in the User Manual. </td> 
         </tr> 
        </tbody>
       </table> 
      </div> 
      <div class="paragraph"> 
       <p>You can make configure on demand the default for a project by adding the following setting to its <em>gradle.properties</em> file:</p> 
      </div> 
      <div class="listingblock"> 
       <div class="content"> 
        <pre class="CodeRay highlight"><code data-lang="java">org.gradle.configureondemand=<span class="predefined-constant">true</span></code></pre> 
       </div> 
      </div> 
     </div> 
     <div class="sect2"> 
      <h3 id="parallel_builds"><a class="anchor" href="#parallel_builds"></a>1.4. Parallel builds</h3> 
      <div class="paragraph"> 
       <p>Few non-trivial builds consist of just one project and when you have a mult-project build, some of those projects are usually independent of one another. Yet Gradle will only ever run one task at a time by default, regardless of the project structure. By using the <code>--parallel</code> switch, you can force Gradle to execute independent subprojects - those that have no implicit or explicit project dependencies between one another - in parallel, allowing it to run multiple tasks at the same time as long as those tasks are in different projects.</p> 
      </div> 
      <div class="paragraph"> 
       <p>You could see big improvements in build times as soon as you enable parallel builds. The extent of those improvements depends on your project structure and how many explicit dependencies you have between them. A build whose execution time is dominated by a single project won’t benefit much at all, for example. Or one that has lots of inter-project dependencies resulting in few projects that can be executed in parallel. But most multi-project builds should see a worthwhile boost to build times.</p> 
      </div> 
      <div class="admonitionblock note"> 
       <table> 
        <tbody>
         <tr> 
          <td class="icon"> <i class="fa icon-note" title="Note"></i> </td> 
          <td class="content"> Parallel builds have similar requirements to configure on demand with regard to decoupled projects. In addition, you should read more about them in <a href="https://docs.gradle.org/current/userguide/multi_project_builds.html#sec:parallel_execution">the User Manual</a> before using them extensively. You need to be more careful in your build configuration and execution than normal to use parallel builds reliably. For example, you should currently avoid running the <code>clean</code> task in combination with other tasks in a parallel build - the User Manual explains why in a warning. </td> 
         </tr> 
        </tbody>
       </table> 
      </div> 
      <div class="paragraph"> 
       <p>You can also make building in parallel the default for a project by adding the following setting to the project’s <em>gradle.properties</em> file:</p> 
      </div> 
      <div class="listingblock"> 
       <div class="content"> 
        <pre class="CodeRay highlight"><code data-lang="groovy">org.gradle.parallel=<span class="predefined-constant">true</span></code></pre> 
       </div> 
      </div> 
      <div class="paragraph"> 
       <p>That’s the end of our quick wins. From here on out, improving your build performance will require some elbow grease. We start with perhaps the most important step: finding out which bits of your build are slow and why.</p> 
      </div> 
     </div> 
    </div> 
   </div> 
   <div class="sect1"> 
    <h2 id="profile_profile_profile"><a class="anchor" href="#profile_profile_profile"></a>2. Profile, profile, profile</h2> 
    <div class="sectionbody"> 
     <div class="paragraph"> 
      <p>As with any attempt to optimize, your first instinct should be to profile the system you’re interested in. Gradle provides two mechanisms for doing this and both of them give you reports that you can view in a browser. Let’s take a look at these two mechanisms - build scans and profile reports - before then discussing how to interpret the information provided in the reports.</p> 
     </div> 
     <div class="sect2"> 
      <h3 id="using_gradle_build_scans"><a class="anchor" href="#using_gradle_build_scans"></a>2.1. Using Gradle build scans</h3> 
      <div class="paragraph"> 
       <p>Build scans are a feature provided by Gradle Inc. that aggregate information across multiple build runs and make those diagnostics available to you online as a report. You can</p> 
      </div> 
      <div class="ulist"> 
       <ul> 
        <li> <p>Easily share scans between developers and build masters</p> </li> 
        <li> <p>Track build performance over time</p> </li> 
        <li> <p>More easily identify the source of a problem</p> </li> 
        <li> <p>Identify issues specific to a single developer site</p> </li> 
       </ul> 
      </div> 
      <div class="paragraph"> 
       <p>Gradle won’t generate build scans automatically, but you can easily enable them by following these steps:</p> 
      </div> 
      <div class="olist arabic"> 
       <ol class="arabic"> 
        <li> <p>Apply the <em>build-scan</em> plugin <a href="https://scans.gradle.com/setup/step-1">as described on Gradle.com</a></p> </li> 
        <li> <p>Run your builds with the <code>-Dscan</code> option, e.g. <code>gradle build -Dscan</code></p> </li> 
       </ol> 
      </div> 
      <div class="paragraph"> 
       <p>At the end of the build, Gradle displays the URL where your build scan awaits your attention.</p> 
      </div> 
      <div class="paragraph"> 
       <p>The build scans themselves provide a lot of information, but the main area of interest in the early stages of diagnosis is the performance page. To get there, follow the link highlighted in the following screenshot of the build scan home page:</p> 
      </div> 
      <div class="imageblock"> 
       <div class="content"> 
        <img src="images/build-scan-home.png" alt="build scan home"> 
       </div> 
       <div class="title">
        Figure 1. Performance page link on build scan home page
       </div> 
      </div> 
      <div class="paragraph"> 
       <p>The performance page gives you a breakdown of how long different stages of your build took to complete. As you can see from the following screenshot, you get to see how long Gradle took to start up, configure the build’s projects, resolve dependencies, and execute the tasks. You also get details about environmental properties, such as whether a daemon was used or not.</p> 
      </div> 
      <div class="imageblock"> 
       <div class="content"> 
        <img src="images/build-scan-performance-page.png" alt="build scan performance page"> 
       </div> 
       <div class="title">
        Figure 2. Build scan performance page
       </div> 
      </div> 
      <div class="paragraph"> 
       <p>We will look into the different categories presented in the report shortly. You can also learn more about build scans <a href="https://gradle.com">at Gradle.com</a>.</p> 
      </div> 
     </div> 
     <div class="sect2"> 
      <h3 id="profile_report"><a class="anchor" href="#profile_report"></a>2.2. Profile report</h3> 
      <div class="paragraph"> 
       <p>If you don’t have internet access or have some other reason not to use build scans, it’s still trivially easy to profile a Gradle build. Simply add the <code>--profile</code> option to the command line args:</p> 
      </div> 
      <div class="literalblock"> 
       <div class="content"> 
        <pre>gradle --profile &lt;tasks&gt;</pre> 
       </div> 
      </div> 
      <div class="paragraph"> 
       <p>This will result in the generation of an HTML report that you can find in the <em>build/reports/profile</em> directory of the <em>root</em> project. Each profile report has a timestamp in its name to avoid overwriting existing ones.</p> 
      </div> 
      <div class="paragraph"> 
       <p>Similar to build scans, the report itself displays a breakdown of the time taken to run the build for a given set of task arguments. Here’s a screenshot of a real profile report showing the different categories that Gradle uses:</p> 
      </div> 
      <div class="imageblock"> 
       <div class="content"> 
        <img src="images/gradle-profile-report.png" alt="Sample Gradle profile report"> 
       </div> 
       <div class="title">
        Figure 3. An example profile report
       </div> 
      </div> 
      <div class="paragraph"> 
       <p>Each of the main categories - <em>Configuration</em>, <em>Dependency Resolution</em>, and <em>Task Execution</em> - may reveal different time sinks that you may want to tackle. We’ll go through those categories in later sections, detailing the types of issue you may encounter for each one. Before then, let’s take a look at some of the items in the summary.</p> 
      </div> 
     </div> 
     <div class="sect2"> 
      <h3 id="understanding_the_profile_report_categories"><a class="anchor" href="#understanding_the_profile_report_categories"></a>2.3. Understanding the profile report categories</h3> 
      <div class="paragraph"> 
       <p>Both build scans and the local profile reports break build execution down into the same categories. We’ll now look at those categories, what they mean, and what sorts of problems you can identify with them.</p> 
      </div> 
      <div class="sect3"> 
       <h4 id="startup"><a class="anchor" href="#startup"></a>2.3.1. Startup</h4> 
       <div class="paragraph"> 
        <p>This reflects Gradle’s initialization time, which consists mostly of</p> 
       </div> 
       <div class="ulist"> 
        <ul> 
         <li> <p>JVM initialization and class loading</p> </li> 
         <li> <p>Downloading the Gradle distribution if you’re using the wrapper</p> </li> 
         <li> <p>Starting the daemon if a suitable one isn’t already running</p> </li> 
         <li> <p>Time spent executing any Gradle initialization scripts</p> </li> 
        </ul> 
       </div> 
       <div class="paragraph"> 
        <p>Even if a build execution has a long startup time, a subsequent run will usually see a dramatic drop off in the startup time. The main reason for a build’s startup time to be persistently slow is a problem in your init scripts. Double check that the work you’re doing there is necessary and as performant as possible.</p> 
       </div> 
      </div> 
      <div class="sect3"> 
       <h4 id="settings_and_em_buildsrc_em"><a class="anchor" href="#settings_and_em_buildsrc_em"></a>2.3.2. Settings and <em>buildSrc</em></h4> 
       <div class="paragraph"> 
        <p>Soon after Gradle has got itself up and running, it initializes your project. This commonly just means processing your <em>settings.gradle</em> file, but if you have custom build logic in a <em>buildSrc</em> directory, that gets built as well.</p> 
       </div> 
       <div class="paragraph"> 
        <p>The sample profile report shows a time of just over 8 seconds for this category, the vast majority of which was spent building the <em>buildSrc</em> project. This part fortunately won’t take so long once <em>buildSrc</em> is built once as Gradle will consider it up to date. The up-to-date checks still take a little time, but nowhere near as much. If you do have problems with a persistently time consuming <em>buildSrc</em> phase, you should consider breaking it out into a separate project whose JAR artifact is added to the build’s classpath.</p> 
       </div> 
       <div class="paragraph"> 
        <p>The <em>settings.gradle</em> file rarely has computationally or IO expensive code in it. If you find that Gradle is taking a significant amount of time to process it, you should use more traditional profiling methods, such as timing statements in <em>settings.gradle</em> or a profiler, to determine why.</p> 
       </div> 
      </div> 
      <div class="sect3"> 
       <h4 id="loading_projects"><a class="anchor" href="#loading_projects"></a>2.3.3. Loading projects</h4> 
       <div class="paragraph"> 
        <p>It normally doesn’t take a significant amount of time to load projects, nor do you have any control over it. The time spent here is basically a function of the number of projects you have in your build.</p> 
       </div> 
       <div class="paragraph"> 
        <p>The rest of the summary relates to the main categories, which we cover in detail in the next sections. Before we do that, there’s one more tool available to you for diagnosing performance problems: Gradle build scans.</p> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
   <div class="sect1"> 
    <h2 id="configuration"><a class="anchor" href="#configuration"></a>3. Configuration</h2> 
    <div class="sectionbody"> 
     <div class="paragraph"> 
      <p>As the user guide describes in <a href="https://docs.gradle.org/current/userguide/build_lifecycle.html">the build lifecycle chapter</a>, a Gradle build goes through three phases: initialization, configuration, and execution. The important thing to understand here is that in non-native Gradle builds, configuration code always executes regardless of which tasks will run. That means any expensive work performed during configuration will permanently cripple the build, even for such things as <code>gradle help</code> and <code>gradle tasks</code>.</p> 
     </div> 
     <div class="paragraph"> 
      <p>The profile report will help you identify which projects take the most time to configure, but that’s all. The next few subsections introduce techniques that can help improve the configuration time and explain why they work.</p> 
     </div> 
     <div class="sect2"> 
      <h3 id="apply_plugins_judiciously"><a class="anchor" href="#apply_plugins_judiciously"></a>3.1. Apply plugins judiciously</h3> 
      <div class="paragraph"> 
       <p>Every plugin that you apply to a project adds to the overall configuration time. Some plugins have a greater impact than others. That doesn’t mean you should avoid using plugins, but you should take care to only apply them where they’re needed. For example, it’s easy to apply plugins to all projects via <code>allprojects {}</code> or <code>subprojects {}</code> even if not every project needs them.</p> 
      </div> 
      <div class="paragraph"> 
       <p>Ideally, plugins should not incur a significant configuration-time cost. If they do, the focus should be on improving the plugin. Nonetheless, in projects with many modules and a significant configuration time, you should spend a little time identifying any plugins that have a notable impact. The only reliable way to do this is by running a build twice: once with the plugin applied and once without.</p> 
      </div> 
     </div> 
     <div class="sect2"> 
      <h3 id="avoid_expensive_or_blocking_work"><a class="anchor" href="#avoid_expensive_or_blocking_work"></a>3.2. Avoid expensive or blocking work</h3> 
      <div class="paragraph"> 
       <p>This is fairly obvious based on what we’ve already said about the configuration phase, but it’s not hard to accidentally break this rule. It’s usually clear when you’re encrypting stuff or calling remote services during configuration if that code is in a build file. But logic like this is more often found in plugins and occasionally custom task classes, where it’s easy to forget which phase your code is running in. Things only get harder to track when they’re factored into short methods and multiple classes.</p> 
      </div> 
      <div class="paragraph"> 
       <p>This is not an argument for putting all your build logic into build scripts. That’s generally a recipe for unmaintainable builds. However, if your profile report is indicating that the build is spending more time than expected in the configuration phase, you should start looking at your plugins and custom task classes. A task should generally rely on the build script or plugin that instantiates it to set its properties, rather than performing the configuration itself. If you’re familiar with the principle of Inversion of Control (IoC), that’s what you should be aiming for.</p> 
      </div> 
     </div> 
     <div class="sect2"> 
      <h3 id="statically_compile_tasks_and_plugins"><a class="anchor" href="#statically_compile_tasks_and_plugins"></a>3.3. Statically compile tasks and plugins</h3> 
      <div class="paragraph"> 
       <p>Plugins and occasionally tasks perform work during the configuration phase. These are often written in Groovy for its concise syntax, API extensions to the JDK, and functional methods using closures. However, it’s important to bear in mind that there is a small cost associated with method calls in dynamic Groovy. When you have lots of method calls repeated across lots of projects, the cost can add up.</p> 
      </div> 
      <div class="paragraph"> 
       <p>In general, we recommend that you use either <code>@CompileStatic</code> on your Groovy classes (where possible) or write those classes in a statically compiled language, such as Java. This only really applies to large projects or plugins that you publish publicly (because they may be applied to large projects by other users). If you do need dynamic Groovy at any point, simply use <code>@CompileDynamic</code> for the relevant methods.</p> 
      </div> 
      <div class="paragraph"> 
       <p><strong>Note</strong> The DSL you’re used to in the build script relies heavily on Groovy’s dynamic features, so if you want to use static compilation in your plugins, you will have to switch to using Gradle’s core API. For example, to create a new copy task, you would use code like this:</p> 
      </div> 
      <div class="listingblock"> 
       <div class="content"> 
        <pre class="CodeRay highlight"><code data-lang="groovy">project.tasks.create(<span class="string"><span class="delimiter">"</span><span class="content">copyFiles</span><span class="delimiter">"</span></span>, Copy) { Task t -&gt;
    t.into <span class="string"><span class="delimiter">"</span><span class="inline"><span class="inline-delimiter">${</span>project.buildDir<span class="inline-delimiter">}</span></span><span class="content">/output</span><span class="delimiter">"</span></span>
    t.from project.configurations.getByName(<span class="string"><span class="delimiter">"</span><span class="content">compile</span><span class="delimiter">"</span></span>)
}</code></pre> 
       </div> 
      </div> 
      <div class="paragraph"> 
       <p>You can see how this example uses the <code>create()</code> and <code>getByName()</code> methods, which are available on all Gradle “domain object containers”, like tasks, configurations, dependencies, extensions, etc. Some collections have dedicated types, <code>TaskContainer</code> being one of them, that have useful extra methods like the <code>create()</code> method above that takes a task type.</p> 
      </div> 
      <div class="paragraph"> 
       <p>If you do decide to use static compilation, we recommend using an IDE as it will quickly show errors due to unrecognised types, properties, and methods. You’ll also get auto-completion, which is always handy.</p> 
      </div> 
     </div> 
    </div> 
   </div> 
   <div class="sect1"> 
    <h2 id="dependency_resolution"><a class="anchor" href="#dependency_resolution"></a>4. Dependency resolution</h2> 
    <div class="sectionbody"> 
     <div class="paragraph"> 
      <p>Software projects rely on dependency resolution to simplify the integration of third-party libraries and other dependencies into the build. This does come at a cost as Gradle has to contact remote servers to find out about said dependencies and download them where necessary. Advanced caching helps speed things up tremendously, but you still need to watch out for a few pitfalls that we discuss next.</p> 
     </div> 
     <div class="sect2"> 
      <h3 id="dynamic_and_snapshot_versions"><a class="anchor" href="#dynamic_and_snapshot_versions"></a>4.1. Dynamic and snapshot versions</h3> 
      <div class="paragraph"> 
       <p>Dynamic versions, such as “2.+”, and snapshot (or changing) versions force Gradle to contact the remote repository to find out whether there’s a new version or snapshot available. By default, Gradle will only perform the check once every 24 hours, but this can be changed. Look out for <code>cacheDynamicVersionsFor</code> and <code>cacheChangingModulesFor</code> in your build files and initialization scripts in case they are set to very short periods or disabled completely. Otherwise you may be condemning your build users to frequent slower-than-normal builds rather than a single slower-than-normal build a day.</p> 
      </div> 
      <div class="paragraph"> 
       <p>You may be able to use fixed versions - like 1.2 and 3.0.3.GA - in which case Gradle will always use the cached version. But if you want or need to use dynamic and snapshot versions, make sure you tune the cache settings according to your requirements.</p> 
      </div> 
     </div> 
     <div class="sect2"> 
      <h3 id="favor_dependency_resolution_during_execution"><a class="anchor" href="#favor_dependency_resolution_during_execution"></a>4.2. Favor dependency resolution during execution</h3> 
      <div class="paragraph"> 
       <p>Dependency resolution is an expensive process, both in terms of IO and computation. Gradle reduces - and eliminates in some cases - the required network traffic through judicious caching, but there is still work it needs to do. Why is this important? Because if you trigger dependency resolution during the configuration phase, you’re going to add a penalty to every build that runs.</p> 
      </div> 
      <div class="paragraph"> 
       <p>The key question to answer is what triggers dependency resolution? The most common cause is the evaluation of the files that make up a configuration. This is normally a job for tasks, since you typically don’t need the files until you’re ready to do something with them in a task action. However, imagine you’re doing some debugging and want to display the files that make up a configuration through judicious caching. One way you can do this is by injecting a print statement:</p> 
      </div> 
      <div class="listingblock"> 
       <div class="content"> 
        <pre class="CodeRay highlight"><code data-lang="groovy">task copyFiles(<span class="key">type</span>: Copy) {
    println <span class="string"><span class="delimiter">"</span><span class="content">&gt;&gt; Compilation deps: </span><span class="inline"><span class="inline-delimiter">${</span>configurations.compile.files<span class="inline-delimiter">}</span></span><span class="delimiter">"</span></span>
    into <span class="string"><span class="delimiter">"</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/output</span><span class="delimiter">"</span></span>
    from configurations.compile
}</code></pre> 
       </div> 
      </div> 
      <div class="paragraph"> 
       <p>The <code>files</code> property will force Gradle to resolve the dependencies, and in this example that’s happening during the configuration phase. Now every time you run the build, no matter what tasks you execute, you’ll take a hit from the dependency resolution on that configuration. It would be better to add this in a <code>doFirst()</code> action.</p> 
      </div> 
      <div class="paragraph"> 
       <p>Note that the <code>from()</code> declaration doesn’t resolve the dependencies because you’re using the configuration itself as an argument, not its files. The <code>Copy</code> task handles the resolution of the configuration itself during task execution, which is exactly what you want.</p> 
      </div> 
      <div class="paragraph"> 
       <p>The performance page of build scans explicitly shows how dependency resolution time is split across project configuration and task execution, so it’s easy to identify this particular issue. If you’re using the older profile reports, a simple way to determine whether you’re resolving dependencies during configuration is to run</p> 
      </div> 
      <div class="literalblock"> 
       <div class="content"> 
        <pre>gradle --profile help</pre> 
       </div> 
      </div> 
      <div class="paragraph"> 
       <p>and look at the time spent on dependency resolution. This should be zero, so if it’s not, you’re resolving dependencies at configuration time. The report will also tell you which configurations are being resolved, which should help in diagnosing the source of the configuration-time resolution.</p> 
      </div> 
     </div> 
     <div class="sect2"> 
      <h3 id="avoid_unnecessary_and_unused_dependencies"><a class="anchor" href="#avoid_unnecessary_and_unused_dependencies"></a>4.3. Avoid unnecessary and unused dependencies</h3> 
      <div class="paragraph"> 
       <p>You will sometimes encounter situations in which you’re only using one or two methods or classes from a third-party library. When that happens, you should seriously consider implementing the required code yourself in the project or copying it from an open source library if that’s an option for you. Remember that managing third-party libraries and their transitive dependencies adds a not insignificant cost to project maintenance as well as build times.</p> 
      </div> 
      <div class="paragraph"> 
       <p>Another thing to watch out for is the existence of <em>unused dependencies</em>. This can easily happen after code refactoring when a third-party library stops being used but isn’t removed from the dependency list. You can use the <a href="https://github.com/nebula-plugins/gradle-lint-plugin">Gradle Lint plugin</a> to identify such dependencies.</p> 
      </div> 
     </div> 
     <div class="sect2"> 
      <h3 id="minimize_repository_count"><a class="anchor" href="#minimize_repository_count"></a>4.4. Minimize repository count</h3> 
      <div class="paragraph"> 
       <p>When Gradle attempts to resolve a dependency, it searches through each repository in the order that they are declared until it finds that dependency. This generally means that you want to declare the repository hosting the largest number of your dependencies first so that only that repository is searched in the majority of cases. You should also limit the number of declared repositories to the minimum viable number for your build to work.</p> 
      </div> 
      <div class="paragraph"> 
       <p>One technique available if you’re using a custom repository server is to create a virtual repository that aggregates several real repositories together. You can then add just that repository to your build file, further reducing the number of HTTP requests that Gradle sends during dependency resolution.</p> 
      </div> 
     </div> 
     <div class="sect2"> 
      <h3 id="be_careful_with_custom_dependency_resolution_logic"><a class="anchor" href="#be_careful_with_custom_dependency_resolution_logic"></a>4.5. Be careful with custom dependency resolution logic</h3> 
      <div class="paragraph"> 
       <p>Dependency resolution is a hard problem to solve and making it perform well simply adds to the challenge. And yet, Gradle still needs to allow users to model dependency resolution in the way that best suits them. That’s why it has a powerful API for customizing how the dependency resolution works.</p> 
      </div> 
      <div class="paragraph"> 
       <p>Simple customizations — such as forcing specific versions of a dependency or substituting one dependency for another — don’t have a big impact on dependency resolution times. But if custom logic involves downloading and parsing extra POMs, for example, then the impact can be significant.</p> 
      </div> 
      <div class="paragraph"> 
       <p>You should use build scans or profile reports to check that any custom dependency resolution logic you have in your build doesn’t adversely affect dependency resolution times in a big way. And note that this could be custom logic you have written yourself or it could be part of a plugin that you’re using.</p> 
      </div> 
     </div> 
    </div> 
   </div> 
   <div class="sect1"> 
    <h2 id="task_execution"><a class="anchor" href="#task_execution"></a>5. Task execution</h2> 
    <div class="sectionbody"> 
     <div class="paragraph"> 
      <p>The fastest task is one that doesn’t execute. If you can find ways to skip tasks you don’t need to run, you’ll end up with a faster build overall. In this section, we’ll discuss a few ways to achieve task avoidance in Gradle.</p> 
     </div> 
     <div class="sect2"> 
      <h3 id="different_people_different_builds"><a class="anchor" href="#different_people_different_builds"></a>5.1. Different people, different builds</h3> 
      <div class="paragraph"> 
       <p>It seems to be very common to treat a build as an all or nothing package. Every user has to learn the same set of tasks that have been defined by the build. In many cases this makes no sense. Imagine you have both front-end and back-end developers: do they want the same things from the build? Of course not, particularly if one side is HTML, CSS and Javascript, while the other is Java and servlets.</p> 
      </div> 
      <div class="paragraph"> 
       <p>It’s important that a single task graph underpins the build to ensure consistency. But you don’t need to expose the entire task graph to everyone. Instead, think in terms of sets of tasks forming a restricted view upon the task graph, with each view designed for a specific group of users. Do front-end developers need to run the server side unit tests? No, so it would make no sense to force the cost of running the tests on those users.</p> 
      </div> 
      <div class="paragraph"> 
       <p>With that in mind, consider the different workflows that each distinct group of users require and try to ensure that they have the appropriate “view” with no unnecessary tasks executed. Gradle has several ways to aid you in such an endeavour:</p> 
      </div> 
      <div class="ulist"> 
       <ul> 
        <li> <p>Assign tasks to appropriate groups</p> </li> 
        <li> <p>Create useful aggregate tasks (ones that have no action and simply depend on a set of other tasks, like <code>assemble</code>)</p> </li> 
        <li> <p>Defer configuration via <code>gradle.taskGraph.whenReady()</code> and others, so you can perform verification only when it’s necessary</p> </li> 
       </ul> 
      </div> 
      <div class="paragraph"> 
       <p>It definitely requires some effort and an investment in time to craft suitable build views, but think about how often users run the build. Surely that investment is worth it if it saves users time on a daily basis?</p> 
      </div> 
     </div> 
     <div class="sect2"> 
      <h3 id="incremental_build"><a class="anchor" href="#incremental_build"></a>5.2. Incremental build</h3> 
      <div class="paragraph"> 
       <p>You can can avoid executing tasks, even if they’re required by a user. If neither a task’s inputs nor its output have changed since the last time it was run, why would it need to run again? It’s up to date, which is why you often see the text <code>UP-TO-DATE</code> next to task names when running a build.</p> 
      </div> 
      <div class="paragraph"> 
       <p>Incremental build is the name Gradle gives to this feature of checking inputs and outputs to determine whether a task needs to run again or not. Most tasks provided by Gradle take part in incremental build because they have been defined that way. You can also make your own tasks integrate with incremental build, as described in the user guide. The basic idea is to mark the task’s properties that have an impact on whether a task needs to run. You can learn more <a href="https://docs.gradle.org/current/userguide/more_about_tasks.html#sec:up_to_date_checks">in the user guide</a>.</p> 
      </div> 
      <div class="paragraph"> 
       <p>Incremental build is definitely a big boon on the whole, as it helps bring build times down significantly. You do need to be aware, though, that it incurs a cost as well, even for a clean build. This is because it needs to generate and verify checksums among other things. This cost is normally insignificant compared to the execution time of a task, but if all your tasks complete in less than a tenth of a second, incremental build may be slower.</p> 
      </div> 
      <div class="paragraph"> 
       <p>You can easily identify good candidates for incremental build or tasks that aren’t up to date when they should be by looking at the Task Execution tab of the build profile report. The tasks are sorted by longest duration first, making it easy to pick out the slowest tasks. If they’re taking longer than half a second, you should probably consider enabling incremental build on them. You can also take the safe approach of making all tasks incremental.</p> 
      </div> 
     </div> 
     <div class="sect2"> 
      <h3 id="partial_builds"><a class="anchor" href="#partial_builds"></a>5.3. Partial builds</h3> 
      <div class="paragraph"> 
       <p>Incremental build definitely improves build times, but you need to remember that the up-to-date checks still take time. This has important implications for multi-project builds that have a large number of subprojects. If the task you want to execute ultimately depends on the execution of twenty other subprojects, you have to wait until the build has finished checking those before it gets round to your task. Some of them may even have non-incremental tasks that end up running, even if nothing has changed.</p> 
      </div> 
      <div class="paragraph"> 
       <p>Gradle offers a nice shortcut if you know that a task’s project dependencies haven’t changed: use the <code>-a</code> command line option. This forces Gradle to effectively ignore all the dependent projects and only execute the required tasks that are defined in the target project. Project dependencies will still be included on the appropriate classpaths, so the project will build as before. Just be sure there haven’t been any changes to the projects the target depends on!</p> 
      </div> 
      <div class="paragraph"> 
       <p>Gradle also supports other forms of partial build via the <em>base</em> plugin, which adds the following tasks:</p> 
      </div> 
      <div class="ulist"> 
       <ul> 
        <li> <p><code>buildNeeded</code> - will execute the <code>build</code> task in the target project and all those projects it depends on. This verifies that the projects you depend on are working correctly. If that’s not the case, they may break the target project’s tests or some other part of the build.</p> </li> 
        <li> <p><code>buildDependents</code> - will execute the <code>build</code> task in the target project and all projects that depend on it. This checks that you haven’t broken those projects after making some changes.</p> </li> 
       </ul> 
      </div> 
      <div class="paragraph"> 
       <p>These tasks are slower than just running <code>build</code> in the target project as they do more work, but they are an effective alternative to running <code>gradle build</code>, which runs <code>build</code> in <em>all</em> the projects of a multi-project build.</p> 
      </div> 
     </div> 
    </div> 
   </div> 
   <div class="sect1"> 
    <h2 id="other_performance_tweaks"><a class="anchor" href="#other_performance_tweaks"></a>6. Other performance tweaks</h2> 
    <div class="sectionbody"> 
     <div class="paragraph"> 
      <p>You will sometimes come across tasks that need to run, but simply take a while. In such cases, you need to look at the task implementation. Or, in the case of third party tasks, such as those provided with Gradle, investigate the task configuration to see whether there are options that will improve the task execution time.</p> 
     </div> 
     <div class="paragraph"> 
      <p>As the final stage of this guide, we’ll look at useful configuration for some of the core Gradle tasks.</p> 
     </div> 
     <div class="sect2"> 
      <h3 id="boost_daemon_s_heap_size"><a class="anchor" href="#boost_daemon_s_heap_size"></a>6.1. Boost daemon’s heap size</h3> 
      <div class="paragraph"> 
       <p>Running builds in memory-constrained environments will have a significant and detrimental impact on the performance of those builds as the garbage collector has to do a lot more work. Attach JConsole or VisualVM to a Gradle daemon process to see whether it’s using close to the maximum heap size. If it is, increase the max heap size through this property in <em>gradle.properties</em>:</p> 
      </div> 
      <div class="literalblock"> 
       <div class="content"> 
        <pre>org.gradle.jvmargs=-Xmx2048M</pre> 
       </div> 
      </div> 
      <div class="paragraph"> 
       <p>You should immediately see an improvement in build times once you’ve done this.</p> 
      </div> 
     </div> 
     <div class="sect2"> 
      <h3 id="running_tests_jvm"><a class="anchor" href="#running_tests_jvm"></a>6.2. Running tests (JVM)</h3> 
      <div class="paragraph"> 
       <p>A significant proportion of the build time for many projects consists of the test tasks that run. These could be a mixture of unit and integration tests, with the latter often being significantly slower. Gradle has a few ways to help your tests complete faster:</p> 
      </div> 
      <div class="ulist"> 
       <ul> 
        <li> <p>Parallel test execution</p> </li> 
        <li> <p>Process forking options</p> </li> 
        <li> <p>Disable report generation</p> </li> 
       </ul> 
      </div> 
      <div class="paragraph"> 
       <p>Let’s look at each of these in turn.</p> 
      </div> 
      <div class="sect3"> 
       <h4 id="parallel_test_execution"><a class="anchor" href="#parallel_test_execution"></a>6.2.1. Parallel test execution</h4> 
       <div class="paragraph"> 
        <p>Gradle will happily run multiple test cases in parallel, which is useful when you have several CPU cores and don’t want to waste most of them. To enable this feature, just use the following configuration setting on the relevant <code>Test</code> task(s):</p> 
       </div> 
       <div class="listingblock"> 
        <div class="content"> 
         <pre class="CodeRay highlight"><code data-lang="groovy">test.maxParallelForks = <span class="integer">4</span></code></pre> 
        </div> 
       </div> 
       <div class="paragraph"> 
        <p>The normal approach is to use some number less than or equal to the number of CPU cores you have. We recommend you use the following algorithm by default:</p> 
       </div> 
       <div class="listingblock"> 
        <div class="content"> 
         <pre class="CodeRay highlight"><code data-lang="groovy">test.maxParallelForks = <span class="predefined-type">Runtime</span>.runtime.availableProcessors().intdiv(<span class="integer">2</span>) ?: <span class="integer">1</span></code></pre> 
        </div> 
       </div> 
       <div class="paragraph"> 
        <p>Note that if you do run the tests in parallel, you will have to ensure that they are independent, i.e. don’t share resources, be that files, databases or something else. Otherwise there is a chance that the tests will interfere with each other in random and unpredictable ways.</p> 
       </div> 
      </div> 
      <div class="sect3"> 
       <h4 id="forking_options"><a class="anchor" href="#forking_options"></a>6.2.2. Forking options</h4> 
       <div class="paragraph"> 
        <p>Gradle will run all tests in a single forked VM by default. This can be problematic if there are a lot of tests or some very memory-hungry ones. One option is to run the tests with a big heap, but you will still be limited by system memory and might encounter heavy garbage collection that slows the tests down.</p> 
       </div> 
       <div class="paragraph"> 
        <p>Another option is to fork a new test VM after a certain number of tests have run. You can do this with the <code>forkEvery</code> setting:</p> 
       </div> 
       <div class="listingblock"> 
        <div class="content"> 
         <pre class="CodeRay highlight"><code data-lang="groovy">test.forkEvery = <span class="integer">100</span></code></pre> 
        </div> 
       </div> 
       <div class="paragraph"> 
        <p>Just be aware that forking a VM is a relatively expensive operation, so a small value here will severely handicap the performance of your tests.</p> 
       </div> 
      </div> 
      <div class="sect3"> 
       <h4 id="report_generation"><a class="anchor" href="#report_generation"></a>6.2.3. Report generation</h4> 
       <div class="paragraph"> 
        <p>Gradle will automatically create test reports by default regardless of whether you want to look at them. That report generation takes time, slowing down the overall build. Reports are definitely useful, but do you need them every time you run the build? Perhaps you only care if the tests succeed or not.</p> 
       </div> 
       <div class="paragraph"> 
        <p>To disable the test reports, simply add this configuration:</p> 
       </div> 
       <div class="listingblock"> 
        <div class="content"> 
         <pre class="CodeRay highlight"><code data-lang="groovy">test {
    reports.html.enabled = <span class="predefined-constant">false</span>
    reports.junitXml.enabled = <span class="predefined-constant">false</span>
}</code></pre> 
        </div> 
       </div> 
       <div class="paragraph"> 
        <p>This example applies to the default <code>Test</code> task added by the Java plugin, but you can also apply the configuration to any other <code>Test</code> tasks you have.</p> 
       </div> 
       <div class="paragraph"> 
        <p>One thing to bear in mind is that you will probably want to conditionally disable or enable the reports, otherwise you will have to edit the build file just to see them. For example, you could enable the reports based on a project property:</p> 
       </div> 
       <div class="listingblock"> 
        <div class="content"> 
         <pre class="CodeRay highlight"><code data-lang="groovy">test {
    <span class="keyword">if</span> (!project.hasProperty(<span class="string"><span class="delimiter">"</span><span class="content">createReports</span><span class="delimiter">"</span></span>)) {
        reports...
    }
}</code></pre> 
        </div> 
       </div> 
      </div> 
     </div> 
     <div class="sect2"> 
      <h3 id="compiling_java"><a class="anchor" href="#compiling_java"></a>6.3. Compiling Java</h3> 
      <div class="paragraph"> 
       <p>The Java compiler is quite fast, especially compared to other languages on the JVM. And yet, if you’re compiling hundreds of non-trivial Java classes, even a short compilation time adds up to something significant. You can of course upgrade your hardware to make compilation go faster, but that can be an expensive solution. Gradle offers a couple of software-based solutions that might be more to your liking:</p> 
      </div> 
      <div class="ulist"> 
       <ul> 
        <li> <p>Compiler daemon</p> </li> 
        <li> <p>Incremental compilation</p> </li> 
       </ul> 
      </div> 
      <div class="paragraph"> 
       <p>Both of these are incubating at the time of writing, but they are worth experimenting with if you’re desperate to eke out better build performance.</p> 
      </div> 
     </div> 
     <div class="sect2"> 
      <h3 id="compiler_daemon"><a class="anchor" href="#compiler_daemon"></a>6.4. Compiler daemon</h3> 
      <div class="paragraph"> 
       <p>The Gradle Java plugin allows you to run the compiler as a separate process by using the following configuration for any <code>JavaCompile</code> task:</p> 
      </div> 
      <div class="literalblock"> 
       <div class="content"> 
        <pre>&lt;taskname&gt;.options.fork = true</pre> 
       </div> 
      </div> 
      <div class="paragraph"> 
       <p>or, more commonly, to apply the configuration to <em>all</em> Java compilation tasks:</p> 
      </div> 
      <div class="literalblock"> 
       <div class="content"> 
        <pre>tasks.withType(JavaCompile) {
    options.fork = true
}</pre> 
       </div> 
      </div> 
      <div class="paragraph"> 
       <p>This has two benefits:</p> 
      </div> 
      <div class="olist arabic"> 
       <ol class="arabic"> 
        <li> <p>Gradle can handle compilation of very large numbers of source files concurrently without forcing you to increase the heap size of the main Gradle process or daemon.</p> </li> 
        <li> <p>The compiler process is reused between builds, significantly reducing the overall compilation times.</p> </li> 
       </ol> 
      </div> 
      <div class="paragraph"> 
       <p>It’s unlikely to be useful for small projects, but you should definitely consider it if a single task is compiling close to a thousand or more source files together.</p> 
      </div> 
     </div> 
     <div class="sect2"> 
      <h3 id="incremental_compilation"><a class="anchor" href="#incremental_compilation"></a>6.5. Incremental compilation</h3> 
      <div class="paragraph"> 
       <p>You may wonder why incremental compilation is an optional extra for Gradle rather than the default. Even IDEs have their own incremental compilers, right? The reason for this state of affairs is the standard Java compiler itself, the one that comes with the JDK.</p> 
      </div> 
      <div class="paragraph"> 
       <p>The standard compiler does attempt to work out what files need recompiling based on a set of changes, but this is rather unreliable. The Java developers amongst you have probably encountered a few instances where you had to run a clean first to fix some compilation issues. So Gradle avoids the potential problems from this by not using the compiler to determine what needs to be recompiled.</p> 
      </div> 
      <div class="paragraph"> 
       <p>Still, incremental compilation can provide real performance benefits, so version 2.1 of Gradle introduced it for Java for the first time. It’s still an incubating feature and may unfortunately have bugs, but it’s very easy to enable and disable. Simply use the following configuration:</p> 
      </div> 
      <div class="listingblock"> 
       <div class="content"> 
        <pre class="CodeRay highlight"><code data-lang="groovy">compileJava.options.incremental = <span class="predefined-constant">true</span></code></pre> 
       </div> 
      </div> 
      <div class="paragraph"> 
       <p>Just be aware that it is still an incubating feature. That said, you can expect continued improvements in future versions of Gradle.</p> 
      </div> 
     </div> 
    </div> 
   </div> 
   <div class="sect1"> 
    <h2 id="suggestions_for_android_builds"><a class="anchor" href="#suggestions_for_android_builds"></a>7. Suggestions for Android builds</h2> 
    <div class="sectionbody"> 
     <div class="paragraph"> 
      <p>Everything we have talked about so far applies to Android builds too, since they’re based on Gradle. Yet Android also introduces its own performance factors, particularly around the CPU-intensive dexing process. Here we provide some additional ideas for improving Android builds specifically.</p> 
     </div> 
     <div class="sect2"> 
      <h3 id="use_the_latest_android_plugin"><a class="anchor" href="#use_the_latest_android_plugin"></a>7.1. Use the latest Android plugin</h3> 
      <div class="paragraph"> 
       <p>The Android plugin is similar to Gradle in that newer versions introduce improved build performance. For example, version 2.10 of the plugin enabled incremental compilation by default and added support for in-process dexing.</p> 
      </div> 
     </div> 
     <div class="sect2"> 
      <h3 id="invest_in_fast_cpus"><a class="anchor" href="#invest_in_fast_cpus"></a>7.2. Invest in fast CPUs</h3> 
      <div class="paragraph"> 
       <p>Since dexing is CPU-intensive, a significantly faster CPU will deliver a significantly faster build. Also note that dexing uses a significant amount of memory, so you should monitor the heap usage for your build when profiling it. You may find it pays to increase the maximum heap size for Gradle.</p> 
      </div> 
     </div> 
     <div class="sect2"> 
      <h3 id="optimize_multidex_development_builds"><a class="anchor" href="#optimize_multidex_development_builds"></a>7.3. Optimize multidex development builds</h3> 
      <div class="paragraph"> 
       <p>Creating multidex output for your project typically adds a significant amount of time to your build due to the merging process. You can mitigate this by setting a minimum SDK version of 21, which allows the Android plugin to perform more efficient dexing.</p> 
      </div> 
      <div class="paragraph"> 
       <p>Of course, in most cases this isn’t feasible in general because older versions of Android are still prevalent and many of you will want to support those devices. However, if you don’t mind developing and testing against SDK 21+ only, then can set up a development flavor that targets a minimum SDK version of 21, while the production flavor targets an older version. This results in a faster build when working on the project code.</p> 
      </div> 
      <div class="paragraph"> 
       <p>Here’s an example partial configuration with the two flavors:</p> 
      </div> 
      <div class="listingblock"> 
       <div class="content"> 
        <pre class="CodeRay highlight"><code data-lang="groovy">android {
    productFlavors {
        dev {
            minSdkVersion <span class="integer">21</span>
        }
        prod {
            minSdkVersion <span class="integer">14</span>
        }
    }
}</code></pre> 
       </div> 
      </div> 
      <div class="paragraph"> 
       <p>You can find out more about this feature in the <a href="https://developer.android.com/studio/build/multidex.html#dev-build">Android Studio user guide</a>. Whether you use this approach or not will depend on how you see the trade off between development build speed and consistency in versions between development and production testing.</p> 
      </div> 
     </div> 
     <div class="sect2"> 
      <h3 id="use_discretion_when_adding_build_types_and_flavors"><a class="anchor" href="#use_discretion_when_adding_build_types_and_flavors"></a>7.4. Use discretion when adding build types and flavors</h3> 
      <div class="paragraph"> 
       <p>The more build types and flavors you create, the longer it will take for Gradle to configure your project. So what you can do is wrap flavor and build type declarations in conditions - via <code>if</code> statements typically - such that whoever runs the build can switch flavors and build type on or off through project or system properties.</p> 
      </div> 
      <div class="paragraph"> 
       <p>For example, if a developer only ever builds debug versions of a project, they could set a project property that disables the non-debug build types and the non-development flavors. They can still build whatever they need simply by passing different property values, but the default would result in a faster build.</p> 
      </div> 
      <div class="paragraph"> 
       <p>This does make builds less maintainable, though, so you should only use this approach where you get a significant boost in build speed. Conventions in property names can help with the build maintenance too.</p> 
      </div> 
     </div> 
    </div> 
   </div> 
   <div class="sect1"> 
    <h2 id="summary"><a class="anchor" href="#summary"></a>8. Summary</h2> 
    <div class="sectionbody"> 
     <div class="paragraph"> 
      <p>Performance is a feature and the Gradle team are always attempting to make the Gradle defaults as fast as possible because they know that their users' time is valuable. Even so, Gradle supports a huge variety of builds, which means that the defaults won’t always be ideal for <em>your</em> project. That’s why we introduced you to some settings and task options that allow you to tweak the behavior of the build in your favor. You should also familiarise yourself with any other available options on your long running tasks and with the generic Gradle build environment settings.</p> 
     </div> 
     <div class="paragraph"> 
      <p>Beyond those settings, remember that the two big contributors to build times are configuration and task execution, although the base cost of the former drops with almost every major Gradle release. And as far as the configuration phase goes, you should now have a good idea of the pitfalls you need to avoid.</p> 
     </div> 
     <div class="paragraph"> 
      <p>You have more control over task execution, since you can avoid running tasks or running them too often, and you can also code your own tasks to be as performant as possible. In the future, Gradle will offer more features to help with execution performance. Things like parallel task execution. You have plenty to look forward to!</p> 
     </div> 
     <div class="paragraph"> 
      <p>In the meantime, we hope the ideas in this guide help you cut your build times and improve the overall user experience.</p> 
     </div> 
    </div> 
   </div> 
  </div> 
  <div id="footer"> 
   <div id="footer-text">
     Last updated 2017-02-17 11:24:41 UTC 
   </div> 
  </div>  
 </body>
</html>